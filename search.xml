<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[node.js中的express框架]]></title>
    <url>%2F2018%2F10%2F18%2Fnodejs%E4%B8%ADexpress%2F</url>
    <content type="text"><![CDATA[node.js中的express框架 掌握nodemon工具的使用 掌握express框架的基本用法 了解express框架提供的中间件的概念 能够连接并操作数据库 了解模块加载机制 1. 使用 nodemon 工具来自动重启web服务器 nodemon的作用：能够实时监听当前项目中，文件的变化；只要监听到了文件的变化，则 nodemon 工具，会自动重新启动 web 服务器，从而使最新的代码生效；免去了程序员手动重启服务器的困扰； 如何安装：运行 npm i nodemon -g 全局安装即可； 如何使用： 之前使用 node 要执行的文件路径 来运行 Node.js 代码； 现在使用 nodemon 要执行的文件路径 来运行 Node.js 代码； 注意：今后在开发Web项目的时候，推荐使用 nodemon 来启动 web 服务器 2. Node 中开发web项目的框架 - express 定义（什么是Express）：一个快速的网站开发框架，封装了原生的http模块，用起来更方便；API更人性化 2.1 express 框架的特点 基于Node.js平台之上，进一步封装了 http 模块，从而提供了更好用，更友好的 API 使用Express创建网站，比使用原生的http模块更加方便； Express 并没有覆盖 原生 http 模块中的方法，而是基于 原生方法之上，做了更友好的封装，让用户体验更好 2.2 express 框架的安装和基本使用 安装：运行 npm i express -S 即可安装 创建基本的 express 服务器： 导入 express 第三方模块； 创建服务器的实例：调用 const app = express() 方法； 通过 app.get() 或 app.post() 方法，来监听客户端的 get 或 post 请求，具体语法： 监听 GET 请求：app.get(&#39;请求地址&#39;, (req, res) =&gt; { 处理函数 }) 监听 POST 请求： app.post(&#39;请求地址&#39;, (req, res) =&gt; { 处理函数 }) 启动 express 服务器：通过 app.listen(端口, IP地址, 启动成功后的回调函数) 启动服务器； 2.3 express 中的快捷方法 res.send() 支持 发送 字符串 Content-Type: text/html; 支持 发送 对象 或 数组 Content-Type: application/json 支持 发送 Buffer 此时会当作文件下载； res.sendFile() 用法1：res.sendFile(path.join(__dirname, &#39;./view/index.html&#39;)) 用法2：res.sendFile(&#39;./view/movie.html&#39;, { root: __dirname }) 注意：res.sendFile() 可以向浏览器发送 静态页面； 2.4 使用 express.static() 快速托管静态资源 如果我们网站中，有很多静态资源需要被外界访问，此时，使用 res.sendFile 就有点力不从心了; 这时候，express 框架，为我们提供了 express.static(&#39;静态资源目录&#39;) 来快速托管指定目录下的所有静态资源文件； 语法1： app.use(express.static(&#39;public&#39;)); app.use()方法，是专门用来注册 中间件； express.static 是express的内置中间件； 语法2：app.use(&#39;/虚拟目录&#39;, express.static(&#39;public&#39;)) 2.5 为 express 框架配置模板引擎渲染动态页面 安装 ejs 模板引擎npm i ejs -S 使用 app.set() 配置默认的模板引擎 app.set(&#39;view engine&#39;, &#39;ejs&#39;) 使用 app.set() 配置默认模板页面的存放路径 app.set(&#39;views&#39;, &#39;./views&#39;) 使用 res.render() 来渲染模板页面res.render(&#39;index.ejs&#39;, { 要渲染的数据对象 })，注意，模板页面的 后缀名，可以省略不写！ 2.6 在 express 中配置 art-template 安装 两个包 cnpm i art-template express-art-template -S 自定义一个模板引擎 app.engine(&#39;自定义模板引擎的名称&#39;, 渲染函数) 将自定义的模板引擎，配置为 express 的默认模板引擎 app.set(&#39;view engine&#39;, &#39;具体模板引擎的名称&#39;) 配置 模板页面得存放路径 app.set(&#39;views&#39;, &#39;路径&#39;) 3. 使用 express 框架中提供的路由来分发请求 什么是路由：路由就是对应关系； 什么叫做后端路由：前端请求的URL地址，都要对应一个后端的处理函数，那么 这种URL地址到 处理函数之间的对应关系，就叫做后端路由； 在Express中，路由的主要职责 就是 把请求分发到对应的处理函数中； 在Express中，如何 定义并使用路由呢？ // 1. 封装单独的 router.js 路由模块文件 const express = require('express') // 创建路由对象 const router = express.Router() router.get('/', (req, res)=>{}) router.get('/movie', (req, res)=>{}) router.get('/about', (req, res)=>{}) // 导出路由对象 module.exports = router express 创建的 app 服务器，如何使用 路由模块呢？ // 导入自己的路由模块 const router = require('./router.js') // 使用 app.use() 来注册路由 app.use(router) 4. Express 框架里 中间件的概念4.1 什么是中间件 定义：中间件就是一个处理函数；只不过这个函数比较特殊，包含了三个参数，分别是 req，res，next 注意：中间件方法中的三个参数： req：请求对象； res：响应对象； next：next()可以被调用，表示调用下一个中间件方法； 4.2 Express 框架中对中间件的5种分类 应用级别的中间件： 挂载到 app 上的中间件 app.get(&#39;URL地址&#39;, （req, res, next）=&gt; {})； 路由级别的中间件： 挂载到 router 对象上的中间件 router.get(&#39;url地址&#39;, (req, res, next)=&gt;{}) 错误级别的中间件： 回调函数中，有四个参数 app.use((err, req, res, next)=&gt;{}) 唯一内置的中间件： express.static() 第三方中间件： 非express框架提供的，需要程序员手动安装才能使用的中间件；body-parser 解析post 表单数据 中间件的概念，了解即可，因为实际开发中，我们都直接使用第三方现成的中间件； 4.3 自己模拟一个解析表单数据的中间件5. Express 中进行数据库操作配置 MySql 数据库环境mysql 第三方模块的介绍和基本配置使用 mysql 第三方模块实现 CRUD6. 模块加载机制优先从缓存中加载 当一个模块初次被 require 的时候，会执行模块中的代码，当第二次加载相同模块的时候，会优先从缓存中查找，看有没有这样的一个模块！ 好处：提高模块的加载速度；不需要每次都重新执行并加载模块！ 核心模块的加载机制 先查找缓存；如果缓存中没有，再去加载核心模块； 用户模块的加载机制 先查找缓存； 如果缓存中没有则尝试加载用户模块； 如果在加载用户模块时候省略了后缀名，则： 首先，严格按照指定的名称去查找 其次，尝试加载后缀名是 .js 的文件 如果没有.js的文件，则尝试加载 .json 结尾的文件 如果没有 .json 的文件，则尝试加载 .node 结尾的文件 查找规则：index -&gt; index.js -&gt; index.json -&gt; index.node 第三方模块的加载机制【了解】 先在项目根目录中查找node_modules文件夹 在node_modules文件夹下，查找模块相关的文件夹 在对应的文件夹下，查找package.json的文件 查找package.json文件中的main属性（指定了模块的入口文件） 如果找到了main属性，同时，main属性指定的文件路径存在，那么尝试加载指定的文件模块 加入没有main属性，或者main属性对应的文件不存在，或者没有package.json,那么会依次尝试加载index.js，index.json,index.node; 如果没有index相关的文件，或者没有指定模块对应文件夹，或者，当前项目根目录中没有node_modules文件夹，则向上一层目录中查找node_modules，查找规则同上！ 最后，如果在项目所在磁盘的盘符根目录中，还找不到对应模块，则报错：cannot find module *** 相关文章art-template 官方文档]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>npm</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js中模块和包的概念]]></title>
    <url>%2F2018%2F10%2F17%2Fnodejs%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Node.js中模块和包的概念Node.js 由三部分组成：ECMAScript 核心 + 全局成员 + 模块成员模块成员，根据一些区别，又可以分为三大类： 核心模块、第三方模块、用户自定义模块 1 模块成员的分类1.1 核心模块 什么是核心模块： 随着 Node.js 的安装包，一同安装到本地的模块，叫做核心模块； 例如：fs，path等模块，都是由 Node.js 官方提供的核心模块； 只要大家在计算机中，安装了 Node 这个应用程序，那么，我们的计算机中就已经安装了所有的 核心模块； 如何使用核心模块：require(&#39;核心模块标识符&#39;) 2.2 第三方模块 什么是第三方模块： 一些非官方提供的模块，叫做第三方模块； 注意，第三方模块，并不在我们的计算机上； 如果大家需要使用某些第三方模块，必须去一个叫做 NPM 的网站上搜索并下载才能使用； 如何使用第三方模块： 先从 npm 官网上下载指定的第三方模块 使用 require(&#39;第三方模块的名称标识符&#39;)来导入这个模块 根据 第三方模块的 官方文档，尝试使用 2.3 用户自定义模块 什么是用户模块： 程序员在自己项目中写的 Javascript 文件，就叫做 用户自定义模块； 如何使用用户模块：require(&#39;路径标识符&#39;) 2 包的定义和使用2.1 什么是 英文名叫做 Packages，包是在模块基础上更深一步的抽象； 包的目的：方便分发和推广基于 CommonJS 规范实现的 应用程序 或 类库； 包可以看作是 模块、代码 和 其它资源 组合起来形成的 独立作用域； 相当于一个入口文件，整合了其他模块,整合资源，向外暴露 2.2 规范的包结构 包都要以一个单独的目录而存在； package.json 必须在包的顶层目录下； package.json 文件必须符合 JSON 格式，并且必须包含如下三个属性：name, version, main name: 包的名字 version: 包的版本号 main: 表示包的入口文件 二进制文件应该在bin 目录下;javaScript 代码应该在lib 目录下; 文档应该在doc 目录下;单元测试应该在test 目录下; Node.js 对包要求并没有那么严格，只要顶层目录下有package.json，并符合基本规范即可; 2.3 包描述文件 package.json【了解】name：包的名称，必须是唯一 description：包的简要说明 version：符合语义化版本识别规范的版本字符串 keywords：关键字数据，通常用于搜索 maintainers：维护者数组，每个元素要包含name、email、web可选字段 contributors：贡献者数组，格式与maintainers相同。包的坐着应该是贡献者数据的第一个元素 bugs：提交bug的地址，可以是网址或者电子邮件地址 licenses：许可证数组，每个元素要包含type和url字段 repositories：仓库托管地址数组，每个元素要包含type、url和path字段 dependencies：包的依赖，一个关联数组，由包名称和版本号组成。 devDependencies：开发依赖项，表示一个包在开发期间用到的依赖项 模块作用域 和 全局作用域 在Node.js中有两个作用域，分别是 全局作用域 和 模块作用域； 全局作用域使用 global 来访问，类似于浏览器中的window； 每个 Javascript 文件，都是一个单独模块，每个模块都有自己独立的作用域，因此：模块中的成员，默认无法被其它模块访问。 1 使用 global 全局作用域在模块之间共享成员 如果在某个模块内部，想为 全局的 global 作用域挂载一些属性，需要显示的调用global.***来挂载； 注意：在开发中，一般情况下，不推荐使用global全局作用域来共享成员，会存在全局变量污染问题； 2 模块作用域 module（模块标识） module 属性是 Common JS 规范中定义的，它是一个对象，表示当前这个具体的 js 模块； require（引用模块） 每一个实现了 CommonJS 规范的模块，必须定义一个 require() 函数，使用这个 require 函数，就能够 很方便的导入其它 模块中的成员，供自己使用； exports（暴露模块成员） 每一个模块中，如果想要把自己的一些私有成员，暴露给别人使用，那么，必须实现一个 exports 对象，通过exports对象，可以方便的把模块内私有的成员，暴露给外界使用； 3 module.exports 和 exports 的关系 module.exports 和 exports 默认引用了同一个空对象； module.exports 和 exports 作用一致，都可以向外暴露成员； 一个模块作用域中，向外暴露私有成员时，永远以 module.exports 为准；]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>模块化</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM概述]]></title>
    <url>%2F2018%2F10%2F16%2Fnpm%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[npm1 npm 的两层含义 NPM 是一个 第三方模块的托管网站，指的就是https://www.npmjs.com/； NPM 是Node的包管理工具（全名叫做 Node package manager），在我们安装Node时候，就已经顺便也安装了 NPM 这个管理工具； 2 安装和卸载全局包（i5ting_toc）把md文件转换为html文件 什么是全局的包：安装到计算机全局环境中的包，叫做全局包；安装的全局包可以在当前电脑的任何目录下，直接通过命令行来访问； 如何安装全局包：运行 npm install 包名 -g 即可；其中 -g 参数，表示 把包安装到全局目录中的意思； 全局包的安装目录：C:\Users\用户目录\AppData\Roaming\npm 什么样的包适合安装到全局：工具性质的包，适合安装到全局； 如何卸载全局包：要卸载某个全局的包，直接运行npm uninstall 包名 -g即可；其中 uninstall 表示卸载的意思； 3 安装和卸载本地包 什么是本地的包：跟着项目安装的包，叫做本地包；本地包都会被安装到 node_modules 目录下； 注意：如果拿到一个空项目，必须在当前项目根目录中，先运行 npm init或者npm init -y 命令，初始化一个package.json的配置文件，否则包无法安装到本地项目中； 如何安装本地包：运行npm i 包名 --save 即可安装本地包；都安装到了当前项目的 node_modules目录下； 如果大家用的是npm 5.x的版本，可以不指定--save命令，如果用的是 npm 3.x 的版本，则需要手动指定 --save； package-lock.json文件中记录了曾经装过的包的下载地址，方便下次直接下载包，能够加快装包的速度，提升装包的体验； 如何卸载本地包：使用 npm uninstall/remove 包名 -S/-D即可卸载指定的本地包； 4 其它常用命令 --save 的缩写是 -S --save-dev的缩写是 -D开发时候使用 install 的缩写是 i 注意：dependencies 节点，表示项目上线部署时候需要的依赖项；devDependencies节点，表示项目在开发阶段需要的依赖项，但是当项目要部署上线了，devDependencies节点中的包，就不再需要了！ 注意：当使用 npm i快速装包的时候，npm会检查package.json文件中，所有的依赖项，然后都为我们安装到项目中 --production 表示只安装 dependencies 节点下，记录的包，不安装devDependencies节点下的包；当项目要上线了，才会使用--production命令 5 解决 npm 下载慢问题 默认，NPM在下载包的时候，连接的是国外的服务器，所以，有时候如果网速不是特别好，可能下载不下来包；此时，大家可以全局安装一个的工具，叫做 cnpm 如何安装cnpm：运行 npm i cnpm -g 即可； 如何使用cnpm：在装包的时候，只需要把 npm 替换成 cnpm 即可，例如： 使用 npm 安装 jquery：运行 npm i jquery -S 使用 cnpm 安装 jquery： 运行 cnpm i jquery -S]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>npm</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用hexo搭建GitHub.io网站]]></title>
    <url>%2F2018%2F09%2F03%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BAGitHub.io%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[前言这一篇主要介绍如何使用hexo搭建GitHub.io网站我自己的网站：https://lijie-1024.github.io使用hexo+next主题+GitHub搭建，具体问题可以留言问我。本篇所包含的内容如下： 正文一、申请github.io网站github注册我就不讲了。。。能想到这个法子创建博客的应该也有账号了。直接创建开始： 创建一个新的资源库，名称为yourname.github.io, 其中yourname是你的github名称，如下： 二、 配置工具 安装Git Bash–百度搜索git bash安装包 自行安装 —可以忽略此步 官方网站：https://git-scm.com/downloads 一路next安装，按window+r 在新打开的窗口中输入cmd，敲击回车，打开命令行界面。输入下面代码，出现版本号就算是安装成功了。git --version 安装NodeJs--百度搜索node.js安装包 下载Node.js安装文件：Windows Installer 32-bitWindows Installer 64-bit 根据自己的Windows版本选择相应的安装文件，要是不知道，就安装32-bit。 一直next到安装完，按window+r 在新打开的窗口中输入cmd，敲击回车，打开命令行界面。输入下面代码，出现版本号就算是安装成功了。node -v npm -v 安装hexo 先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。 文件夹内右键加shift打开命令行窗口，或者路径cmd打开运行： npm i -g hexo 等待自动下载hexokinase包 初始化命令运行：hexo init 完成之后可以看到文件node_modules：是依赖包public：存放的是生成的页面scaffolds：命令生成文章等的模板source：用命令创建的各种文章themes：主题_config.yml：整个博客的配置db.json：source解析所得到的package.json：项目所需模块项目的配置信息 然后输入：npm install —–之后npm将会自动安装你需要的组件，只需要等待npm操作即可。 完成以上操作就配置好了基础 。 三、 部署项目 使用编辑器打开你的文件—_config.yml：文件，在最后加入下面三行代码。 更改路程为自己的名称https://github.com/‘你github的名称’/‘你github的名称’.github.io.gitdeploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master cmd到根目录打开窗命令行依次输入hexo clean hexo generate hexo server 作用hexo clean –整理 ；hexo generate –生成htnl页面；hexo server–在端口4000中打开（可以简写为hexo s） 打开浏览器输入：http://localhost:4000 到这里就可以本地看到自己的网站啦~~ 四、上传到github cmd命令行安装npm包：npm install hexo-deployer-git –save cmd执行命令(建议每次都按照如下步骤部署)：hexo clean hexo generate hexo deploy 注意deploy的过程中要输入你的username及passward。如下： 在浏览器中输入http://yourgithubname.github.io就可以看到你的个人博客啦~~~例如我的：https://lijie-1024.github.io 五、绑定个人域名—可以忽略 购买域名：我自己的是在腾讯云买的，http://hm1024.club 添加CNAME：在项目的source文件夹下新建一个名为CNAME的文件，在里面添加你购买的域名，只能添加一个 到DNS中解析记录： 其中ip地址为你的github的地址 可在cmd命令行中输入：ping yourname.github.io 再次部署一次，就可以在域名中打开了 hexo clean hexo g （简写） hexo d （简写） 在浏览器中输入http://yourgithubname.github.io就可以看到你的个人博客啦！！完美~ 小结 基本上这几个操作按顺序下来就可以完美创建你的博客了！ 下一篇讲：修改hexo主题和一些功能的添加。 结束，有问题可以留言]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中的动画]]></title>
    <url>%2F2018%2F08%2F23%2Fvue%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[Vue中的动画 为什么要有动画：动画能够增加页面趣味性，目的是为了让用户更好的理解页面的功能； Vue中的动画，都是简单的过渡动画，并不会有 CSS3 那么炫酷； Vue中动画的基本介绍 每个都动画分为两部分： 入场动画：从不可见（flag = false） -&gt; 可见（flag = true） 出场动画：可见（flag = true） -&gt; 不可见（flag = false） 入场时候，Vue把这个动画，分成了两个时间点和一个时间段： v-enter：入场之前 v-enter-to：入场完成以后 v-enter-active：入场的时间段 离场时候，Vue把动画，分成了两个时间点和一个时间段： v-leave：离场之前 v-leave-to：离场完成以后 v-leave-active：离场的时间段 使用过渡类名 把需要添加动画的元素，使用v-if或v-show进行控制 把需要添加动画的元素，使用Vue提供的元素 &lt;transition&gt;&lt;/transition&gt; 包裹起来 添加两组类： .v-enter, .v-leave-to{ opacity: 0; transform: translateX(100px); } .v-enter-active, .v-leave-active{ transition: all 0.5s ease; } 使用第三方 CSS 动画库 把需要添加动画的元素，使用v-if或v-show进行控制 把需要添加动画的元素，使用Vue提供的元素 &lt;transition&gt;&lt;/transition&gt; 包裹起来 为 &lt;transition&gt;&lt;/transition&gt; 添加两个属性类enter-active-class, leave-active-class 把需要添加动画的元素，添加一个 class=&quot;animated&quot; 使用动画钩子函数 注意：使用过渡类名或第三方CSS动画库实现的过渡动画，都是完整的动画，同时包含了 入场 和 出场 两种状态； 如果想要实现半场动画,只能借助于 动画钩子函数来实现； v-for 的列表过渡列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和： .v-move{ transition: all 0.8s ease; } /*控制要被删除的元素，脱离标准流*/ .v-leave-active{ position: absolute; }]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue品牌管理案例]]></title>
    <url>%2F2018%2F08%2F20%2Fvue%E5%93%81%E7%89%8C%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[品牌管理案例 添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的 filterBy 指令，在 2.x 中已经被废除：filterBy - 指令 &lt;tr v-for="item in list | filterBy searchName in 'name'"> &lt;td>{{item.id}}&lt;/td> &lt;td>{{item.name}}&lt;/td> &lt;td>{{item.ctime}}&lt;/td> &lt;td> &lt;a href="#" @click.prevent="del(item.id)">删除&lt;/a> &lt;/td> &lt;/tr> 在 2.x 版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： &lt;hr> 输入筛选名称： &lt;input type="text" v-model="searchName"> 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的 methods 方法，同时，把过滤条件searchName传递进去： &lt;tbody> &lt;tr v-for="item in search(searchName)"> &lt;td>{{item.id}}&lt;/td> &lt;td>{{item.name}}&lt;/td> &lt;td>{{item.ctime}}&lt;/td> &lt;td> &lt;a href="#" @click.prevent="del(item.id)">删除&lt;/a> &lt;/td> &lt;/tr> &lt;/tbody> search 过滤方法中，使用 数组的 filter 方法进行过滤： search(name) { return this.list.filter(x => { return x.name.indexOf(name) != -1; }); }]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue生命周期]]></title>
    <url>%2F2018%2F08%2F19%2Fvue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[vue实例的生命周期概念：每一个Vue实例创建、运行、销毁的过程，就是生命周期；在实例的生命周期中，总是伴随着各种事件，这些事件就是生命周期函数； 什么是生命周期（每个实例的一辈子）生命周期：实例的生命周期，就是一个阶段，从创建到运行，再到销毁的阶段；(https://cn.vuejs.org/v2/guide/instance.html#实例生命周期)生命周期函数：在实例的生命周期中，在特定阶段执行的一些特定的事件，这些事件，叫做 生命周期函数； 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类 创建期间的生命周期函数：(特点：每个实例一辈子只执行一次) beforeCreate：创建之前，此时 data 和 methods 尚未初始化 created(第一个重要的函数，此时，data 和 methods 已经创建好了，可以被访问了) beforeMount：挂载模板结构之前，此时，页面还没有被渲染到浏览器中； mounted（第二个重要的函数，此时，页面刚刚被渲染出来；如果要操作DOM元素，最好在这个阶段） 运行期间的生命周期函数：（特点：按需被调用 至少0次，最多N次） beforeUpdate：数据是最新的，页面是旧的 updated：页面和数据都是最新的 销毁期间的生命周期函数：(特点：每个实例一辈子只执行一次) beforeDestroy：销毁之前，实例还正常可用 destroyed：销毁之后，实例已经不工作了]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM的概念]]></title>
    <url>%2F2018%2F07%2F18%2FBOM%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[BOMBOM的概念BOM(Browser Object Model) 是指浏览器对象模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象。 我们在浏览器中的一些操作都可以使用BOM的方式进行编程处理， 比如：刷新浏览器、后退、前进、在浏览器中输入URL等 BOM的顶级对象windowwindow是浏览器的顶级对象，当调用window下的属性和方法时，可以省略window注意：window下一个特殊的属性 window.name 对话框 alert() prompt() confirm() 页面加载事件 onload window.onload = function () { // 当页面加载完成执行 // 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行 } onunload window.onunload = function () { // 当用户退出页面时执行 } 定时器setTimeout()和clearTimeout()在指定的毫秒数到达之后执行指定的函数，只执行一次 // 创建一个定时器，1000毫秒后执行，返回定时器的标示 var timerId = setTimeout(function () { console.log('Hello World'); }, 1000); // 取消定时器的执行 clearTimeout(timerId); setInterval()和clearInterval()定时调用的函数，可以按照给定的时间(单位毫秒)周期调用函数 // 创建一个定时器，每隔1秒调用一次 var timerId = setInterval(function () { var date = new Date(); console.log(date.toLocaleTimeString()); }, 1000); // 取消定时器的执行 clearInterval(timerId); location对象location对象是window对象下的一个属性，时候的时候可以省略window对象 location可以获取或者设置浏览器地址栏的URL URL统一资源定位符 (Uniform Resource Locator, URL) URL的组成 scheme://host:port/path?query#fragment scheme:通信协议 常用的http,ftp,maito等 host:主机 服务器(计算机)域名系统 (DNS) 主机名或 IP 地址。 port:端口号 整数，可选，省略时使用方案的默认端口，如http的默认端口为80。 path:路径 由零或多个&#39;/&#39;符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。 query:查询 可选，用于给动态网页传递参数，可有多个参数，用&#39;&amp;&#39;符号隔开，每个参数的名和值用&#39;=&#39;符号隔开。例如：name=zs fragment:信息片断 字符串，锚点. location有哪些成员？ 使用chrome的控制台查看 查MDN MDN 成员 assign()/reload()/replace() hash/host/hostname/search/href…… 案例解析URL中的query，并返回对象的形式 function getQuery(queryStr) { var query = {}; if (queryStr.indexOf('?') > -1) { var index = queryStr.indexOf('?'); queryStr = queryStr.substr(index + 1); var array = queryStr.split('&amp;'); for (var i = 0; i &lt; array.length; i++) { var tmpArr = array[i].split('='); if (tmpArr.length === 2) { query[tmpArr[0]] = tmpArr[1]; } } } return query; } console.log(getQuery(location.search)); console.log(getQuery(location.href)); history对象 back() forward() go() navigator对象 userAgent 通过userAgent可以判断用户浏览器的类型 platform 通过platform可以判断浏览器所在的系统平台类型. 特效偏移量 offsetParent用于获取定位的父级元素 offsetParent和parentNode的区别 var box = document.getElementById('box'); console.log(box.offsetParent); console.log(box.offsetLeft); console.log(box.offsetTop); console.log(box.offsetWidth); console.log(box.offsetHeight); 客户区大小var box = document.getElementById('box'); console.log(box.clientLeft); console.log(box.clientTop); console.log(box.clientWidth); console.log(box.clientHeight); 滚动偏移var box = document.getElementById('box'); console.log(box.scrollLeft) console.log(box.scrollTop) console.log(box.scrollWidth) console.log(box.scrollHeight)]]></content>
      <categories>
        <category>webAPI</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>API</tag>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2018%2F07%2F03%2Fwebpack%2F</url>
    <content type="text"><![CDATA[webpack1. 在网页中会引用哪些常见的静态资源？ 样式表 .css/.less/.scss JS文件 .js/.ts 图片 .jpg/.jpeg/.png/.gif/.bmp/.svg/.webp 字体文件 .eot/.ttf/.woff/.woff2/.svg 模板文件 .vue/.jsx 2. 网页中引入的静态资源多了以后有什么问题？？？ 对网页性能不友好：要发起很多的静态资源请求，降低页面的加载效率，用户体验差； 对程序开发不友好：前端程序员要处理复杂的文件之间的依赖关系； 3. 如何解决上述两个问题 对于 JS 文件 或 CSS 文件，可以合并和压缩；小图片适合转 Base64 格式的编码； 通过一些工具，让工具自动维护文件之间的依赖关系； 4. 什么是webpack? 什么是webpack：webpack 是前端项目的构建工具；前端的项目，都是基于 webpack 进行 构建和运行的； 什么项目适合使用webpack： webpack 非常适合与单页面应用程序结合使用； 不太适合与多页面的普通网站结合使用； 为什么要使用webpack: 如果项目使用 webpack 进行构建，我们可以书写高级的ES代码，且不用考虑兼容性； webpack 能够优化项目的性能； 基于webpack，程序员可以把 自己的开发重心，放到功能上； 根据官网的图片介绍webpack打包的过程 webpack官网 5. 在项目中安装和配置webpack webpack 就是前端的一个工具，这个工具，已经被托管到了NPM官网上； 新建一个项目的空白目录，并在在终端中，cd到项目的根目录，执行npm init -y 初始化项目 装包：运行 cnpm i webpack webpack-cli -D 安装项目构建所需要的 webpack 打开 package.json文件，在 scripts 节点中，新增一个 dev 的节点： "scripts": { "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev": "webpack" }, 在项目根目录中，新建一个 webpack.config.js 配置文件，内容如下： // 这是 使用 Node 语法， 向外导出一个 配置对象 module.exports = { mode: &#39;production&#39; // production development } 在项目根目录中，新增一个 src 目录，并，在 src 目录中，新建一个 index.js 文件，作为 webpack 构建的入口； 在项目根目录中，新增一个 dist 目录 在终端中，直接运行 npm run dev 启动webpack进行项目构建； 6. 初步使用webpack构建项目7. 实现webpack的实时打包构建 借助于 webpack-dev-sever 这个工具，能够实现 webpack 的实时打包构建； 运行cnpm i webpack-dev-server -D 安装包 打开package.json文件，把 scripts 节点下的 dev 脚本，修改为如下配置： "scripts": { "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev": "webpack-dev-server" }, 修改 index.html 文件中的 script 的 src, 让 src 指向 内存中根目录下的 /main.js &lt;script src="/main.js">&lt;/script> node ./app.js nodemon ./app.js webpack webpack-dev-server 8. 使用html-webpack-plugin插件配置启动页面 装包cnpm i html-webpack-plugin -D 在 webpack.config.js中，导入 插件： // 导入 html-webpack-plugin，从而帮我们自动把 打包好的 main.js 注入到 index.html 页面中 // 同时，html-webpack-plugin 可以把 磁盘上的 index.html 页面，复制一份并托管到 内存中； const HtmlPlugin = require('html-webpack-plugin') const htmlPlugin = new HtmlPlugin({ // 传递一个配置对象 template: './src/index.html', // 指定路径，表示 要根据哪个物理磁盘上的页面，生成内存中的页面 filename: 'index.html' // 指定，内存中生成的页面的名称 }) 把 创建好的 htmlPlugin 对象，挂载到 plugins数组中： // webpack 这个构建工具，是基于 Node.js 开发出来的一个前端工具 module.exports = { mode: 'development', // 当前处于开发模式 plugins: [htmlPlugin] // 插件数组 } 9. 实现自动打开浏览器、热更新和配置浏览器的默认端口号 --open 自动打开浏览器 --host 配置IP地址 --port 配置 端口号 --hot 热更新；最新的代码，以打补丁的形式，替换到页面上，加快编译的速度； 10. 打包处理非js文件 使用 ES6 模块化规范，导入 样式表 默认，webpack 只能帮我们打包处理js类型的文件，非JS后缀名的文件，webpack默认处理不了。如果webpack 发现有处理不了的文件类型，则 尝试去查找，是否安装了对应的loader，来处理这种文件类型； 如果有，则调用 对应的loader加载器， 帮webpack处理这种文件类型； 当第三方 loader 处理完以后，会把 处理的结果，返回给 webpack 进行 打包合并； 如果没有合适的第三方loader则报错； 10.1 使用webpack打包css文件 运行 cnpm i style-loader css-loader -D 在webpack.config.js配置文件的导出对象上，新增一个module对象节点，在 对象中，新增一个 rules数组，格式如下： module: { // 所有非JS结尾的文件类型模块，都在这里进行配置 rules: [ // 文件处理规则 { test: /\.css$/, use: ['style-loader', 'css-loader'] } // 配置 所有 CSS 文件的 处理 loader ] } 10.2 使用webpack打包less文件 运行 cnpm i less-loader less -D 在rules中新增一个规则： { test: /\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] } // 处理 less 文件的 loader 10.3 使用webpack打包scss文件 运行 cnpm i sass-loader node-sass -D 在 rules中新增一个规则： { test: /\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] } // 处理 scss 文件的loader 10.4 使用webpack处理css中的路径 运行 cnpm i url-loader -D 在 rules中新增一个规则： { test: /\.jpg|jpeg|png|gif|svg$/, use: 'url-loader' } // 处理 样式表中 图片路径的loader 10.5 使用babel处理高级JS语法 运行命令安装两套包： 第一个套命令： cnpm i babel-core babel-loader babel-plugin-transform-runtime -D 第二套命令： cnpm i babel-preset-env babel-preset-stage-0 -D 添加 rules规则： { test: /\.js$/, use: 'babel-loader', exclude: /node_modules/ } // 处理JS高级语法的loader ; 注意： 一定要添加 exclude 排除项，把 node_modules 目录排除 在项目根目录中，添加一个 .babelrc 配置文件： { "presets": ["env", "stage-0"], "plugins": ["transform-runtime"] } 10.6 处理 字体文件路径问题 还是使用 url-loader 进行处理 添加 rules规则： { test: /\.ttf|woff|woff2|eot|svg$/, use: 'url-loader' }, // 处理 字体 文件的 loader 11. ES6 中模块化规范 暴露成员方式1： export default { } 每个模块中，只能使用1次 这种方式暴露的成员，在接收的时候，可以使用任意名称来接收； 暴露成员方式2：export var a = 10 每个模块中可以多次使用 export 暴露成员给外界； 暴露的成员，必须使用 import {} from &#39;模块&#39;来接收 暴露的成员，在接收的时候，必须使用指定的名称来接收；但是，接收完以后；可以使用 as 关键字改名 导入成员的三种方式： import obj from &#39;模块&#39; import &#39;模块&#39; import { 需要按需接收的成员 } from &#39;模块&#39; 或 `import obj, { 按需导入的成员 } from ‘模块’ 相关文章babel-preset-env：你需要的唯一Babel插件Runtime transform 运行时编译es6]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode插件使用大全]]></title>
    <url>%2F2018%2F07%2F03%2Fvscode%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[vscodeVS Code（Visual Studio Code）是由微软研发的一款免费、开源的跨平台文本（代码）编辑器。前端开发几乎完美的编辑器。 推荐我所使用的插件 打开： open in browser浏览器打开文件，快捷键：alt+b 或右键打开 自动刷新–&gt;Live Server右键打开或终端打开，local host：5500选择文件，自动刷新。 样式类： Bracket Pair Colorizer括号高亮显示 change-case清洁代码，普通文本一键转换包括驼峰命名、下划线分隔命名，snake_case 命名以及 CONST_CAS 命名等。 Color Infocss样式颜色提示，可以自动选择颜色。鼠标停留就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。 GlassIt-VSC使vscode软件整体变透明的插件，包括背景，字体，透明度可以调节。ctrl+alt+z透明，ctrl+alt+c恢复正常。我自己特别喜欢，把vscode放在浏览器上面，配合自动保存，和自动刷新，只要一改代码，就立马能看见效果。主题：我最喜欢的三个： One Dark Pro 黑色背景 很舒服。 high contrast 黑色背景 高对比度，配合背景透明，调到很低也很清晰。 light 白色背景 也很清晰。不适合配合透明。 代码提示： intelliSense for CSS class names in HTML把项目中link引用的 css 文件内里的名称智能提示在 html 中。 jQuery Code SnippetsjQuery代码提示。例如：jqajax–&gt;自动生成ajax样式 JavaScript (ES6) snippetsJavaScript (ES6) 代码提示。 SQL Server (mssql)sql语句代码提示。 ExpressJs 4 Snippets用于VS Code的ExpressJs 4代码段。 Veturvue 代码提示。 Vue 2 SnippetsVue 2 代码段。 Bootstrap 4, Font awesome 4, Font Awesome 5 Free &amp; Pro snippetsBootstrap 4代码提示片段。 工具类： 自动保存vscode 自带功能，选项栏： 文件–&gt;选择自动保存 vscode-pdfvscode中打开pdf格式文档。 Image Preview鼠标移到路径里显示图像预览。 Easy LESSless格式语法自动转换相对应css文件，方便引用。 htmltagwrap在选中HTML标签中外面套一层别的标签 “Alt + W” 。 Auto Rename Tag 自动重命名标签，关联使用，更改开始标签，结束标签同时更改。 Path Intellisense路径补全。 功能类： Chinese (Simplified) Language Pack for Visual Studio Code简体中文版。 Prettier - Code formatter代码格式化软件，支持：html，css，js，json，php，nodejs、等，强烈推荐！使用方式： · CMD + Shift + P -&gt; Format Document · 重新绑定editor.action.formatDocument，在editor.action.formatSelection在vscode的键盘快捷键菜单。 CSS Peek追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。 vue-peek同css peek，追踪 vue定义的地方。 ESLint在团队协作中，为避免低级 Bug、产出风格统一的代码，公司会预先制定编码规范。EsLint帮助我们检查Javascript编程时的语法错误。比如：在Javascript应用中，你很难找到你漏泄的变量或者方法。EsLint能够帮助我们分析JS代码，找到bug并确保一定程度的JS语法书写的正确性。具体安装教程，借鉴：https://blog.csdn.net/walid1992/article/details/54633760?utm_source=blogxgwz0 总结以上都是亲自使用过的，强烈推荐哦~~~]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>插件</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
</search>
